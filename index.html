<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>README</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="butterfly-">Butterfly前端开发规范</h1>
<h2 id="-html-">页面的HTML结构</h2>
<pre><code>&lt;div id=&quot;rootName&quot; data-view=&quot;pathToJS&quot;&gt;
    // 1：本View相关的CSS定义
    &lt;style&gt;
        // 所有CSS定义之前，必须添加#rootName以限定CSS仅对本View生效
        #rootName .viewCSSName {
        }
    &lt;/style&gt;

    // 2：本View相关Template定义
    &lt;script id=&quot;templateName&quot; type=&quot;text/x-underscore-template&quot;&gt;
        …
    &lt;/script&gt;
    …
    &lt;script id=&quot;templateName&quot; type=&quot;text/x-underscore-template&quot;&gt;
        …
    &lt;/script&gt;

    // 3：本View的Header定义
    &lt;header id=&quot;nav-bar&quot; class=&quot;bar bar-nav blue-bar&quot; navLeft=&#39;{&quot;hide&quot;:&quot;true&quot;}&#39; navTitle=&#39;&quot;这是标题&quot;&#39; navRight=&#39;{&quot;hide&quot;:&quot;true&quot;}&#39;&gt;
    &lt;/header&gt;

    // 4：本View的UI定义,class必须指定为content
    &lt;div class=&quot;content&quot;&gt;
        …
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><ul>
<li><p>说明:</p>
<p>  1：页面HTML文件充当UI结构和布局，充当View角色    </p>
<p>  2：data-view中pathToJS指定了该View对应的JS文件，建立View-Controller的关系 </p>
<p>  3：Template定义块和Header定义块为可选</p>
<p>  4：View的实际内容放在UI定义块里面，内容中UI位置均相对于.content div设置，不能依赖于.content div以外的任何节点</p>
</li>
</ul>
<h2 id="-js-">页面的JS文件</h2>
<pre><code>define([
        &quot;dependentClassBase&quot;, 
        &quot;dependentModel0&quot;, 
        &quot;dependentModel1&quot;,
         …
    ],
    function(ClassBase, Model0, Model1, …) {    
        // 定义内部常量(Inner Variable)和内部函数(Inner Function)
        var CONSTANT_VARIBALE = &quot;THIS IS A CONSTANT STRING&quot;;
        var innerFunction = function() {
        }            

        // 定义类(Class)
        var Class = {};

        // 类构造函数
        Class.constructor = function(options) {
            // 调用基类的构造函数，构造基类
            ClassBase.prototype.contructor.call(this, options);

            // 构造自己
            // 定义类成员变量
            this._memberVariable = xxx;
        }

        // 定义类public成员函数
        Class.publicMemberFunction = function() {
        }
        ……

        // 定义类private、protected成员函数
        Class._privateMemberFunction = function() {
        }

        Class._protectedMemberFunction = function() {
        }

        // 让Class类继承于ClassBase，导出Class
        return ClassBase.extend(Class);        
    });
</code></pre><ul>
<li><p>说明</p>
<p>  1：define相关语法参加require.js文档</p>
<p>  2：页面的JS文件充当Controller，该页面的逻辑在此实现，通过HTML中data-view和HTML建立绑定关系</p>
<p>  3：仅仅在该类中使用的常量和函数优先于类定义</p>
<p>  4：该类的成员变量，应该在constructor中定义和初始化，并且使用_memberVariable的格式命名</p>
<p>  5：优先定义该类的public成员函数，然后定义private、protected成员函数，并且private、protected成员函数使用_privateMemberFunction命名（参见命名规则）</p>
<p>  6：private、protected的成员函数和成员变量对外应该是不可见的，外部不应该调用和使用具有_前缀的函数和变量（参见命名规则）</p>
</li>
</ul>
<h1 id="google-javascript-">Google JavaScript 语言规范指南</h1>
<h2 id="-">变量</h2>
<p>声明变量必须加上 var 关键字.</p>
<p>当你没有写 var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么, 变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 var 去声明变量.</p>
<h2 id="-">常量</h2>
<p>常量的形式如:NAMES_LIKE_THIS, 即使用大写字符, 并用下划线分隔.请永远不要使用 const 关键词.    </p>
<h2 id="-">分号</h2>
<p>总是使用分号.</p>
<p>如果仅依靠语句间的隐式分隔, 有时会很麻烦. 你自己更能清楚哪里是语句的起止.</p>
<p>而且有些情况下, 漏掉分号会很危险:</p>
<pre><code>1.  MyClass.prototype.myMethod = function() {
        return 42; 
    }  // No semicolon here. 

    (function() {   
    // Some initialization code wrapped in a function to create a scope for locals. 
    })(); 

2.  // Trying to do one thing on Internet Explorer and another on Firefox. 
    // I know you&#39;d never write code like this, but throw me a bone. 
    var x = {
        &#39;i&#39;: 1,
        &#39;j&#39;: 2
    }  // No semicolon here.

    [normalVersion, ffVersion][isIE]();   

3.  var THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  // No semicolon here.  

    // conditional execution a la bash
    -1 == resultOfOperation() || die();
</code></pre><ul>
<li><p>这段代码会发生些什么诡异事呢?</p>
<p>  1.报 JavaScript 错误. 例子1上的语句会解释成, 一个函数带一匿名函数作为参数而被调用, 返回42后, 又一次被&quot;调用&quot;, 这就导致了错误.</p>
<p>  2.例子2中, 你很可能会在运行时遇到 &#39;no such property in undefined&#39; 错误, 原因是代码试图这样 x[ffVersion][isIE]() 执行.</p>
<p>  3.当 resultOfOperation() 返回非 NaN 时, 就会调用die, 其结果也会赋给 THINGS_TO_EAT.</p>
</li>
<li><p>为什么</p>
<p>  JavaScript 的语句以分号作为结束符, 除非可以非常准确推断某结束位置才会省略分号. 上面的几个例子产出错误, 均是在语句中声明了函数/对象/数组直接量, 但闭括号( &#39;}&#39; 或 &#39;]&#39; )并不足以表示该语句的结束. 在 JavaScript 中, 只有当语句后的下一个符号是后缀或括号运算符时, 才会认为该语句的结束.</p>
<p>  遗漏分号有时会出现很奇怪的结果, 所以确保语句以分号结束.</p>
</li>
</ul>
<h2 id="-">块内函数声明</h2>
<p>不要在块内声明一个函数.不要写成:</p>
<pre><code>if (x) {   
    function foo() {
    } 
}
</code></pre><p>虽然很多JS引擎都支持块内声明函数, 但它不属于 ECMAScript 规范 (见 ECMA-262, 第13和14条). 各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背. ECMAScript 只允许在脚本的根语句或函数中声明函数. </p>
<p>如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:</p>
<pre><code>if (x) {   
    var foo = function() {
    } 
}
</code></pre><h2 id="-">闭包</h2>
<p>可以使用, 但需小心使用.闭包也许是JS中最有用的特性了. <a href="http://jibbering.com/faq/faq_notes/closures.html">这里有一份比较好的介绍闭包原理的文档</a>.</p>
<p>有一点需要牢记, 闭包保留了一个指向它封闭作用域的指针, 所以, 在给 DOM 元素附加闭包时, 很可能会产生循环引用, 进一步导致内存泄漏. 比如下面的代码:</p>
<pre><code>function foo(element, a, b) {   
    element.onclick = function() {
        /* uses a and b */ 
    }; 
}
</code></pre><p>这里, 即使没有使用 element, 闭包也保留了 element, a 和 b 的引用, . 由于 element 也保留了对闭包的引用, 这就产生了循环引用, 这就不能被 GC 回收. 这种情况下, 可将代码重构为:</p>
<pre><code>function foo(element, a, b) {   
    element.onclick = bar(a, b); 
}  

function bar(a, b) {   
    return function() {
        /* uses a and b */ 
    } 
}
</code></pre><h2 id="eval-">eval()</h2>
<p>只用于解析序列化串 (如: 解析 RPC 响应)</p>
<p>eval() 会让程序执行的比较混乱, 当 eval() 里面包含用户输入的话就更加危险. 可以用其他更佳的, 更清晰, 更安全的方式写你的代码, 所以一般情况下请不要使用 eval(). 当碰到一些需要解析序列化串的情况下(如, 计算 RPC 响应), 使用 eval 很容易实现.</p>
<p>解析序列化串是指将字节流转换成内存中的数据结构. 比如, 你可能会将一个对象输出成文件形式:</p>
<pre><code>users = [
        {     
            name: &#39;Eric&#39;,    
            id: 37824,     
            email: &#39;jellyvore@myway.com&#39;   
       },   
       {     
            name: &#39;xtof&#39;,     
            id: 31337,     
            email: &#39;b4d455h4x0r@google.com&#39;   
       },   
       ... 
   ];
</code></pre><p>很简单地调用 eval 后, 把表示成文件的数据读取回内存中.</p>
<p>类似的, eval() 对 RPC 响应值进行解码. 例如, 你在使用 XMLHttpRequest 发出一个 RPC 请求后, 通过 eval () 将服务端的响应文本转成 JavaScript 对象:</p>
<pre><code>var userOnline = false; 
var user = &#39;nusrat&#39;; 

var xmlhttp = new XMLHttpRequest(); 
xmlhttp.open(&#39;GET&#39;, &#39;http://chat.google.com/isUserOnline?user=&#39; + user, false); 
xmlhttp.send(&#39;&#39;); //Server returns: // userOnline = true;

if (xmlhttp.status == 200) {
    eval(xmlhttp.responseText); 
} // userOnline is now true.
</code></pre><h2 id="for-in-">for-in 循环</h2>
<p>只用于 object/map/hash 的遍历</p>
<p>对 Array 用 for-in 循环有时会出错. 因为它并不是从 0 到 length - 1 进行遍历, 而是所有出现在对象及其原型链的键值. 下面就是一些失败的使用案例:</p>
<pre><code>function printArray(arr) {   
    for (var key in arr) {     
        print(arr[key]);   
    } 
}  
printArray([0,1,2,3]);  // This works.  
var a = new Array(10); 
printArray(a);  // This is wrong.  
a = document.getElementsByTagName(&#39;*&#39;); 
printArray(a);  // This is wrong.  

a = [0,1,2,3]; 
a.buhu = &#39;wine&#39;; 
printArray(a);  // This is wrong again.  

a = new Array; 
a[3] = 3; 
printArray(a);  // This is wrong again.
</code></pre><p>而遍历数组通常用最普通的 for 循环</p>
<pre><code>function printArray(arr) {  
    var l = arr.length;   
    for (var i = 0; i &lt; l; i++) {
        print(arr[i]);   
    }
}
</code></pre><h2 id="-">关联数组</h2>
<p>永远不要使用 Array 作为 map/hash/associative 数组.</p>
<p>数组中不允许使用非整型作为索引值, 所以也就不允许用关联数组. 而取代它使用 Object 来表示 map/hash 对象. Array 仅仅是扩展自 Object (类似于其他 JS 中的对象, 就像 Date, RegExp 和 String)一样来使用.</p>
<h2 id="-">多行字符串</h2>
<p>不要这样写长字符串:</p>
<pre><code>var myString = &#39;A rather long string of English text, an error message \                 
        actually that just keeps going and going -- an error \                 
        message to make the Energizer bunny blush (right through \                 
        those Schwarzenegger shades)! Where was I? Oh yes, \                 
        you\&#39;ve got an error and all the extraneous whitespace is \                 
        just gravy.  Have a nice day.&#39;;
</code></pre><p>在编译时, 不能忽略行起始位置的空白字符; &quot;\&quot; 后的空白字符会产生奇怪的错误; 虽然大多数脚本引擎支持这种写法, 但它不是 ECMAScript 的标准规范.</p>
<h2 id="array-object-">Array 和 Object 直接量</h2>
<p>使用 Array 和 Object 语法, 而不使用 Array 和 Object 构造器.</p>
<p>使用 Array 构造器很容易因为传参不恰当导致错误.</p>
<pre><code>// Length is 3. 
var a1 = new Array(x1, x2, x3);  

// Length is 2. 
var a2 = new Array(x1, x2);  

// If x1 is a number and it is a natural number the length will be x1. 
// If x1 is a number but not a natural number this will throw an exception. 
// Otherwise the array will have one element with x1 as its value. 
var a3 = new Array(x1);  

// Length is 0. 
var a4 = new Array();
</code></pre><p>如果传入一个参数而不是2个参数, 数组的长度很有可能就不是你期望的数值了.</p>
<p>为了避免这些歧义, 我们应该使用更易读的直接量来声明.</p>
<pre><code>var a = [x1, x2, x3]; 
var a2 = [x1, x2]; 
var a3 = [x1]; 
var a4 = [];
</code></pre><p>虽然 Object 构造器没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明.</p>
<pre><code>var o = new Object();  
var o2 = new Object(); 
o2.a = 0; 
o2.b = 1; 
o2.c = 2; 
o2[&#39;strange key&#39;] = 3;
</code></pre><p>应该写成:</p>
<pre><code>var o = {};  
var o2 = {   a: 0,   b: 1,   c: 2,   &#39;strange key&#39;: 3 };
</code></pre><h2 id="-">修改内置对象的原型</h2>
<p>千万不要修改内置对象</p>
<p>如 Object.prototype 和 Array.prototype 的原型. 而修改内置对象, 如 Function.prototype 的原型, 虽然少危险些, 但仍会导致调试时的诡异现象. 所以也要避免修改其原型.</p>
<h1 id="google-javascript-">Google JavaScript 编码风格</h1>
<h2 id="-">命名</h2>
<ul>
<li><p>通常使用</p>
<p>  functionNamesLikeThis</p>
<p>  variableNamesLikeThis </p>
<p>  ClassNamesLikeThis</p>
<p>  EnumNamesLikeThis</p>
<p>  methodNamesLikeThis</p>
<p>  SYMBOLIC_CONSTANTS_LIKE_THIS</p>
<p>  _privateVariableNamesLikeThis</p>
<p>  _privateMethodNamesLikeThis</p>
</li>
<li><p>属性和方法</p>
<p>  文件或类中的 私有 属性, 变量和方法名应该以下划线 &quot;_&quot; 开头.</p>
<p>  保护属性, 变量和方法名不需要下划线开头, 和公共变量名一样.</p>
</li>
<li><p>方法和函数参数</p>
<p>  可选参数以 opt_ 开头.</p>
<p>  函数的参数个数不固定时, 应该添加最后一个参数 var_args 为参数的个数. 你也可以不设置 var_args而取代使用 arguments. </p>
</li>
<li><p>Getters 和 Setters</p>
<p>  Getters 和 setters 并不是必要的. 但只要使用它们了, 就请将 getters 命名成 getFoo() 形式, 将 setters 命名成 setFoo(value) 形式. (对于布尔类型的 getters, 使用 isFoo() 也可.)</p>
</li>
<li><p>文件名</p>
<p>  文件名应该使用小写字符, 以避免在有些系统平台上不识别大小写的命名方式. 文件名以.js结尾, 不要包含除 - 和 <em> 外的标点符号(使用 - 优于 </em>).</p>
</li>
</ul>
<h2 id="-">编码风格</h2>
<p>{}统一使用如下两种风格</p>
<pre><code>function func()
{
}
</code></pre><p>or</p>
<pre><code>function func() {
}
</code></pre><h2 id="-tostring-">自定义 toString() 方法</h2>
<p>应该总是成功调用且不要抛异常.</p>
<p>可自定义 toString() 方法, 但确保你的实现方法满足: (1) 总是成功 (2) 没有其他负面影响. </p>
<p>如果不满足这两个条件, 那么可能会导致严重的问题, 比如, 如果 toString() 调用了包含 assert 的函数, assert 输出导致失败的对象, 这在 toString() 也会被调用.</p>
<h2 id="-">字符串</h2>
<p>使用 &#39; 优于 &quot;</p>
<p>单引号 (&#39;) 优于双引号 (&quot;). 当你创建一个包含 HTML 代码的字符串时就知道它的好处了.</p>
<pre><code>var msg = &#39;This is some HTML&#39;;
</code></pre><h2 id="javascript-">JavaScript 类型</h2>
<p>JavaScript中的类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型示例</th>
<th style="text-align:center">值示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">1e5</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">new Number(true)</td>
<td style="text-align:center">Number 对象</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">&#39;Hello&#39;</td>
<td style="text-align:center">字符串值</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">new String(&#39;Hello&#39;)</td>
<td style="text-align:center">字符串对象</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">布尔值</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">new Boolean(true)</td>
<td style="text-align:center">布尔对象</td>
</tr>
<tr>
<td style="text-align:center">RegExp</td>
<td style="text-align:center">new RegExp(&#39;hello&#39;)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">new Date()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">Null</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">Undefined</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">function f() {  return;}</td>
<td style="text-align:center">没有返回值</td>
</tr>
<tr>
<td style="text-align:center">Array</td>
<td style="text-align:center">[&#39;foo&#39;, 0.3]</td>
<td style="text-align:center">类型不明确的数组</td>
</tr>
<tr>
<td style="text-align:center">Array.<number></td>
<td style="text-align:center">[11, 22, 33]</td>
<td style="text-align:center">整型数组</td>
</tr>
<tr>
<td style="text-align:center">Array.<Array.<string>&gt;</td>
<td style="text-align:center">[&#39;foo&#39;, &#39;bar&#39;]]</td>
<td style="text-align:center">字符串数组的数组</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">{}</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Object.<string></td>
<td style="text-align:center">{&#39;foo&#39;: &#39;bar&#39;}</td>
<td style="text-align:center">值为字符串的对象.</td>
</tr>
<tr>
<td style="text-align:center">Object.<number, string></td>
<td style="text-align:center">var obj = {}; obj[1] = &#39;bar&#39;;</td>
<td style="text-align:center">键为整数, 值为字符串的对象</td>
</tr>
<tr>
<td style="text-align:center">Function</td>
<td style="text-align:center">function(x, y) { return x * y; }</td>
<td style="text-align:center">函数对象</td>
</tr>
<tr>
<td style="text-align:center">function(number, number): number</td>
<td style="text-align:center">function(x, y) {   return x * y; }</td>
<td style="text-align:center">函数值</td>
</tr>
<tr>
<td style="text-align:center">SomeClass</td>
<td style="text-align:center">function SomeClass() {};  new SomeClass();</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SomeInterface</td>
<td style="text-align:center">function SomeInterface() {};  SomeInterface.prototype.draw = function() {};</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">project.MyClass</td>
<td style="text-align:center">project.MyClass = function () {};  new project.MyClass()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">project.MyEnum</td>
<td style="text-align:center">project.MyEnum = { BLUE: &#39;#0000dd&#39;};</td>
<td style="text-align:center">枚举</td>
</tr>
<tr>
<td style="text-align:center">Element</td>
<td style="text-align:center">document.createElement(&#39;div&#39;)</td>
<td style="text-align:center">DOM 中的元素</td>
</tr>
<tr>
<td style="text-align:center">Node</td>
<td style="text-align:center">document.body.firstChild</td>
<td style="text-align:center">DOM 中的节点.</td>
</tr>
<tr>
<td style="text-align:center">HTMLInputElement</td>
<td style="text-align:center">htmlDocument.getElementsByTagName(&#39;input&#39;)[0]</td>
<td style="text-align:center">DOM 中, 特定类型的元素.</td>
</tr>
</tbody>
</table>
<h1 id="google-javascript-tips-tricks">Google JavaScript Tips &amp; Tricks</h1>
<h2 id="true-false-">True &amp; False 表达式</h2>
<ul>
<li><p>下面的布尔表达式都返回 false</p>
<p>  null</p>
<p>  undefined</p>
<p>  &#39;&#39; 空字符串</p>
<p>  0 数字0</p>
</li>
<li><p>但小心下面的, 可都返回 true</p>
<p>  &#39;0&#39; 字符串0</p>
<p>  [] 空数组</p>
<p>  {} 空对象</p>
</li>
</ul>
<p>下面为比较糟糕的代码</p>
<pre><code>while (x != null) {
</code></pre><p>你可以直接写成下面的形式(只要你希望 x 不是 0 和空字符串, 和 false)</p>
<pre><code>while (x) {
</code></pre><p>如果你想检查字符串是否为 null 或空:</p>
<pre><code>if (y != null &amp;&amp; y != &#39;&#39;) {
</code></pre><p>但这样会更好:</p>
<pre><code>if (y) {
</code></pre><h2 id="-">条件三元运算符(？：)</h2>
<p>三元操作符用于替代下面的代码</p>
<pre><code>if (val != 0) {
    return foo();
} else {
    return bar();
}
</code></pre><p>你可以写成:</p>
<pre><code>return val ? foo() : bar();
</code></pre><p>在生成 HTML 代码时也是很有用的:</p>
<pre><code>var html = &#39;&lt;input type=&quot;checkbox&quot;&#39; 
        + (isChecked ? &#39; checked&#39; : &#39;&#39; )
        + (isEnabled ? &#39;&#39; : &#39; disabled’)
        +’ name=&quot;foo&quot;&gt;&#39;;
</code></pre><h2 id="-">&amp;&amp; ||</h2>
<p>二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项.</p>
<p>&quot;||&quot; 被称作为 &#39;default&#39; 操作符, 因为可以这样:</p>
<pre><code>function foo(opt_win) {   
    var win;   
    if (opt_win) {     
        win = opt_win;   
    } else {     
        win = window;   
    }   
}
</code></pre><p>你可以使用它来简化上面的代码:</p>
<pre><code>function foo(opt_win) {   
    var win = opt_win || window;   
}
</code></pre><p>&quot;&amp;&amp;&quot; 也可简短代码.比如:</p>
<pre><code>if (node) {   
    if (node.kids) {     
        if (node.kids[index]) {       
            foo(node.kids[index]);     
        }   
    } 
}
</code></pre><p>你可以像这样来使用:</p>
<pre><code>if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) {   
    foo(node.kids[index]); 
}
</code></pre><p>或者:</p>
<pre><code>var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index]; 
if (kid) {  
    foo(kid);
}
</code></pre><p>不过这样就有点儿过头了:</p>
<pre><code>node &amp;&amp; node.kids &amp;&amp; node.kids[index] &amp;&amp; foo(node.kids[index]);
</code></pre><h2 id="join-">join()来创建字符串</h2>
<p>通常是这样使用的:</p>
<pre><code>function listHtml(items) {   
    var html = &#39;&lt;div class=&quot;foo&quot;&gt;&#39;;   
    for (var i = 0; i &lt; items.length; ++i) {     
        if (i &gt; 0) {       
            html += &#39;, &#39;;     
        }     
        html += itemHtml(items[i]);   
    }           
    html += &#39;&lt;/div&gt;&#39;; 

    return html; 
}
</code></pre><p>但这样在 IE 下非常慢, 可以用下面的方式:</p>
<pre><code>function listHtml(items) {   
    var html = [];   
    for (var i = 0; i &lt; items.length; ++i) {     
        html[i] = itemHtml(items[i]);   
    }

    return &#39;&lt;div class=&quot;foo&quot;&gt;&#39; + html.join(&#39;, &#39;) + &#39;&lt;/div&gt;&#39;;
}
</code></pre><p>你也可以是用数组作为字符串构造器, 然后通过 myArray.join(&#39;&#39;) 转换成字符串. 不过由于赋值操作快于数组的 push(), 所以尽量使用赋值操作.</p>
<h2 id="-node-list">遍历Node List</h2>
<p>Node lists 是通过给节点迭代器加一个过滤器来实现的. 这表示获取他的属性, 如 length 的时间复杂度为 O(n), 通过 length 来遍历整个列表需要 O(n^2).</p>
<pre><code>var paragraphs = document.getElementsByTagName(&#39;p&#39;); 
for (var i = 0; i &lt; paragraphs.length; i++) {   
    doSomething(paragraphs[i]); 
}
</code></pre><p>这样做会更好:</p>
<pre><code>var paragraphs = document.getElementsByTagName(&#39;p&#39;); 
for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) {   
    doSomething(paragraph); 
}
</code></pre><p>这种方法对所有的 collections 和数组(只要数组不包含 falsy 值) 都适用.</p>
<p>在上面的例子中, 也可以通过 firstChild 和 nextSibling 来遍历孩子节点.</p>
<pre><code>var parentNode = document.getElementById(&#39;foo&#39;); 
for (var child = parentNode.firstChild; child; child = child.nextSibling) {   
    doSomething(child); 
}
</code></pre><h2 id="parting-words">Parting Words</h2>
<ul>
<li><p>保持一致性</p>
<p>  当你在编辑代码之前, 先花一些时间查看一下现有代码的风格. 如果他们给算术运算符添加了空格, 你也应该添加. 如果他们的注释使用一个个星号盒子, 那么也请你使用这种方式.</p>
<p>  代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述. 我们在这提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格. 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐. 所以, 避免这种情况的发生.</p>
</li>
</ul>
<h1 id="-">我学到的（或想到了）</h1>
<ul>
<li><p>使用 var 声明每一个变量，常量命名形式使用大写加下划线，每条语句结束需加结束符。</p>
</li>
<li><p>使用驼峰式命名对象、函数和实例。使用帕斯卡式命名构造函数或类。使用下划线 _开头命名私有属性</p>
</li>
<li><p>使用直接量创建数组，对象</p>
</li>
<li><p>向数组增加元素时使用push(),数组转成字符串使用join(),遍历数组不使用for-in,深拷贝数组使用slice()</p>
</li>
<li><p>优先使用 === 和 !== 而不是 == 和 !=</p>
</li>
<li><p>使用闭包时要注意是否存在循环引用，如果有则需考虑 改写成不使用闭包的形式 或 不使用后手动将引用赋值为null。</p>
</li>
<li><p>使用单引号包裹字符串，不使用双引号，字符串过长需使用连接符写成多行</p>
</li>
<li><p>使用 . 来访问对象的属性。当通过变量访问属性时使用中括号 []。</p>
</li>
<li><p>条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则：</p>
<p>  对象 被计算为 true</p>
<p>  Undefined 被计算为 false</p>
<p>  Null 被计算为 false</p>
<p>  布尔值 被计算为 布尔的值</p>
<p>  数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true</p>
<p>  字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true</p>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>